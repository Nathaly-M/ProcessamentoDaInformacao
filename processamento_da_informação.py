# -*- coding: utf-8 -*-
"""Processamento da Informação

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KTYL6ynOIZDU590GXmksZxLlryEwJGYY

# Instruções

- Certifique-se que a configuração está correta (Python 3).

Crie uma função chamada criptografa_par_impar que é variação da Cifra de Cesar. Nessa versão, você deve aplicar a criptografia para cada palavra. Se o comprimento da palavra for par, você deve deslocar os caracteres em 3 posições. Se o comprimento for impar, você deve deslocar em 5 posições.
A célula com o comando assert será usada para testar a implementação.
"""

def criptografa_par_impar(frase):
  lista = frase.split()
  lista_criptografada = []
  palavra_criptografada = ""
  for palavra in lista:
    if len(palavra) % 2 == 0:
      for letra in palavra:
        palavra_criptografada += chr(ord(letra)+3)
      lista_criptografada.append(palavra_criptografada)
      palavra_criptografada = ""
    else:
      for letra in palavra:
        palavra_criptografada += chr(ord(letra)+5)
      lista_criptografada.append(palavra_criptografada)
      palavra_criptografada = ""
  nova_frase = " ".join(lista_criptografada)
  return nova_frase

"""O jogo pedra-papel-tesoura (também chamado de jokenpô) é um jogo de mãos recreativo e simples para duas ou mais pessoas. O jogo é frequentemente empregado como método de seleção (como na escolha de equipes para a prática desportiva, por exemplo).

No pedra-papel-tesoura, os jogadores devem simultaneamente esticar a mão, na qual cada um formou um símbolo (que significa pedra, papel ou tesoura). Então, os jogadores comparam os símbolos para decidir quem ganhou, da seguinte forma:

- Pedra ganha da tesoura.
- Tesoura ganha do papel.
- Papel ganha da pedra.

A pedra é simbolizada por um punho fechado; a tesoura, por dois dedos esticados; e o papel, pela mão aberta. Caso dois jogadores façam o mesmo gesto, ocorre um empate.

Faça uma função chamada `jokenpo` que recebe como entrada a jagada de dois jogadores (representado pelas strings `pedra`, `papel` ou `tesoura`) e retorna 1 se o primeiro jogador ganhou, 2 se o segundo jogador ganhou, e 0 em caso de empate.

A célula com o comando assert será usada para testar a implementação.
"""

jogador1 = str(input('JOKENPÔ!:'))
jogador2 = str(input('JOKENPÔ!:'))

def jokenpo(jogador1, jogador2):
    if jogador1 == 'pedra' and jogador2 == 'tesoura':
      return 1
    if jogador1 == 'tesoura' and jogador2 == 'papel':
      return 1
    if jogador1 == 'papel' and jogador2 == 'pedra':
      return 1
    if jogador1 == 'papel' and jogador2 == 'tesoura':
      return 2
    if jogador1 == 'pedra' and jogador2 == 'papel':
      return 2
    if jogador1 == 'tesoura' and jogador2 == 'pedra':
      return 2
    if jogador1 == 'tesoura' and jogador2 == 'tesoura':
      return 0
    if jogador1 == 'pedra' and jogador2 == 'pedra':
      return 0
    if jogador1 == 'papel' and jogador2 == 'papel':
      return 0

print(jokenpo(jogador1, jogador2))

assert jokenpo('pedra','tesoura')==1
assert jokenpo('tesoura','pedra')==2
assert jokenpo('tesoura','papel')==1
assert jokenpo('papel','tesoura')==2
assert jokenpo('papel','pedra')==1
assert jokenpo('pedra','papel')==2
assert jokenpo('pedra','pedra')==0
assert jokenpo('tesoura','tesoura')==0
assert jokenpo('papel','papel')==0

"""Podemos representar um ponto  p  no espaço  n -dimensional como uma lista de  n  elmentos numéricos. Dado dois pontos  p  e  q , podemos calcular a distância Euclideana entre eles como

![image.png](data:image/png;base64,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)

Abaixo temos uma função em Python chamada distancia_euclideana que receba duas listas de números de mesmo tamanho, e calcule a distância Euclideana entre eles.

A célula com o comando assert será usada para testar a implementação.
"""

import math

def distancia_euclideana(p,q):

  n = len(p)
  soma = 0

  for i in range(n):
    soma  +=  math.pow(p[i] - q[i], 2)

  return math.sqrt(soma)

assert distancia_euclideana([1],[2]) == 1
assert distancia_euclideana([1,1],[2,2]) == 1.4142135623730951
assert distancia_euclideana([1,1,1],[2,2,2]) == 1.7320508075688772
assert distancia_euclideana([1,1,1,1],[2,2,2,2]) == 2

"""Crie uma função chama intercala_lista que receba duas listas  A  e  B  de igual tamanho e cria uma nova lista  C , intercalando os seus elementos. A nova lista  C  criada deve ter duas vezes o tamanho das listas de entrada  A  e  B , e, começando pelo primeiro elemento de  A , intercalar os elmentos de  A  e  B  sucessivamente (primeiro de  A , primeiro de  B , segundo de  A , segundo de  B , ..., último de  A , último de  B ).

A célula com o comando assert será usada para testar a implementação.
"""

def intercala_lista(a,b):
  A = len(a)
  c = []
  for i in range(A):
    c.append(a[i])
    c.append(b[i])
  return c

def intercala_lista(A, B):

  if A == [] and B == []:
    return []

  for i in range(len(A)):
    for j in range(len(B)):
      C = A + B
      C[::2] = A
      C[1::2] = B

  return C

assert intercala_lista([1,3,5],[2,4,6]) == [1,2,3,4,5,6]
assert intercala_lista([2,4,6],[1,3,5]) == [2,1,4,3,6,5]
assert intercala_lista(['a','c','e'],['b','d','f']) == ['a','b','c','d','e','f']
assert intercala_lista([],[]) == []
assert intercala_lista([1],[2]) == [1,2]
assert intercala_lista([1,2],['a','b']) == [1,'a',2,'b']

"""Faça um Programa para uma loja de tintas. O programa deverá pedir o tamanho em metros quadrados da área a ser pintada. Considere que a cobertura da tinta é de 1 litro para cada 12 metros quadrados e que a tinta é vendida em latas de 18 litros, que custam 80,00 reais ou em galões de 3,6 litros, que custam 25,00 reais.

Informe ao usuário as quantidades de tinta a serem compradas e os respectivos preços em 3 situações:

- comprar apenas latas de 18 litros;
- comprar apenas galões de 3,6 litros;
- misturar latas e galões, de forma que o desperdício de tinta seja menor.

Acrescente 10% de folga nos três casos (isto é, você deve adicionar 10% sobre o total de litros de tinta necessário) e sempre arredonde os valores para cima, isto é, considere latas cheias.
"""

import math

metros_quadrados = float(input("Informe o área a ser pintada, em metros quadrados: "))
folga = metros_quadrados * 1.1
litros = folga / 12

latas1 = math.ceil(litros / 18)
valor1 = latas1 * 80
print('Adquirindo apenas latas de 18 litros, será(ão) necessária(s)', latas1,'lata(s) e custará', valor1, 'reais.')

galoes1 = math.ceil(litros / 3.6)
valor2 = galoes1 * 25
print('Adquirindo apenas galões de 3,6 litros será(ão) necessária(s)', galoes1,'galão(ões) e custará', valor2, 'reais.')

latas2 = math.floor(litros / 18)
valor_latas = latas2 * 80
resto = litros % 18
galoes2 = math.ceil(resto / 3.6)
valor_galoes = galoes2 * 25
total = valor_latas + valor_galoes
print('Adquirindo', latas2, 'lata(s) de 18 litros e', galoes2, 'galão(ões) de 3,6 litros custará', total, 'reais.')

"""Faça um programa que sorte um número inteiro entre zero e dez usando a biblioteca random (veja o método randint). O programa deve então solicitar que o usuário acerte o número, e ficar em um laço solicitando novos números até que o usuário acerte o número.

"""

import random

a = random.randint(0, 10)
b =  int(input("Qual número sorteado? "))

while b != a:
  print("Poxa, tente novamente.")
  b =  int(input("Qual número sorteado? "))
else:
  print("Parabéns!")

"""Faça um programa que leia o limite inferior e o superior de um intervalo, e conte quantos números detro deste intervalo são múltiplos, individualmente, de 3, 5, e de 3 e 5 ao mesmo tempo.

"""

x = int(input("Digite o limite inferior: "))
y = int(input("Digite o limite superior: ")) + 1Faça um programa que leia o limite inferior e o superior de um intervalo, e conte quantos números detro deste intervalo são múltiplos, individualmente, de 3, 5, e de 3 e 5 ao mesmo tempo.
m3 = 0
m5 = 0
m35 = 0

for i in range(x, y):
  if i % 3 == 0:
    m3 = m3 + 1
  if i % 5 == 0:
    m5 = m5 + 1
  if i % 3 == 0 and i % 5 == 0:
    m35 = m35 + 1

print("A quantidade de múltiplos de 3 no intervalo mencionado é de:", m3)
print("A quantidade de múltiplos de 5 no intervalo mencionado é de:", m5)
print("E por fim, a quantidade de múltiplos tanto de 3 quanto de 5 no intervalo mencionado é de:", m35)

"""Faça uma função chamada reverte_palavras que receba como entrada uma frase por meio de uma variável string e retorna uma nova frase com o reverso de cada palavra (cada palavra de trás pra frente). Considere que a frase não contém qualquer pontuação, somente palavras."""

def reverte_palavras(frase):
  lista = frase.split()
  nova_lista = []
  for palavra in lista:
    nova_lista.append(palavra[::-1])
    nova_frase = " ".join(nova_lista)
  return nova_frase

assert reverte_palavras("o rato roeu a roupa do rei de roma")=="o otar ueor a apuor od ier ed amor"
assert reverte_palavras("adias a data da saída")=="saida a atad ad adías"
assert reverte_palavras("arara rara")=="arara arar"

"""Crie uma função em Python chamada conta_par que recebe como entrada uma lista de números inteiros e retorna a quantidade de números pares presentes nesta lista"""

lista = []

def conta_par(lista):
  cont = 0
  for p in lista:
    if p%2 == 0:
      cont = cont + 1
  return cont

assert conta_par([]) == 0
assert conta_par([2,2,2,2,2]) == 5
assert conta_par([1,1,1,1,1]) == 0
assert conta_par([1,2,1,2,1,2]) == 3

"""Faça uma função em Python chamada conta_igual que recebe como entrada duas listas a e b de mesmo tamanho e conta quantos elementos dessas duas listas são iguais na mesma posição (ou seja, conta quantos elementos a[i] são iguais a b[i] para todos os elmentos dessas duas listas."""

lista_a = []
lista_b = []

def conta_igual(lista_a, lista_b):
  cont = 0
  for n in range(len(lista_a)):
    if lista_a[n] == lista_b[n]:
      cont = cont + 1
  return cont

assert conta_igual([],[]) == 0
assert conta_igual([1,2,3],[3,2,1]) == 1
assert conta_igual([1,1,1],[-1,-1,-1]) == 0
assert conta_igual([0,0,0],[0,0,0]) == 3
assert conta_igual([1],[2]) == 0

"""Crie uma função chamada maior_por_coluna que recebe como entrada uma matriz numérica, e retorna uma lista com o maior elemento de cada coluna."""

def maior_por_coluna(m):
  maior = [0]*len(m[0])
  for linha in range(len(m)):
    for coluna in range(len(m[linha])):
      if m[linha][coluna] > maior[coluna]:
        maior[coluna] = m[linha][coluna]

  return maior

A = [[1,2,3],
     [4,5,6],
     [7,8,9]]

B = [[1,0],
     [0,1]]

C = [[0,1],
     [1,0],
     [1,1]]

D = [[1,1,2],
     [2,2,1],
     [2,1,3]]


assert maior_por_coluna(A)==[7,8,9]
assert maior_por_coluna(B)==[1,1]
assert maior_por_coluna(C)==[1,1]
assert maior_por_coluna(D)==[2,2,3]

"""Crie uma função chamada posicao_do_maior que recebe como entrada uma matriz numérica, e retorna uma lista com a posição ([linha,coluna]) do maior elmento da matriz (caso haja multiplas ocorrências do maior elemento, retornar a posição da primeira ocorrência)."""

def posicao_do_maior(m):
  maior = m[0][0]
  posicao = [0,0]
  for linha in range(len(m)):
    for coluna in range (len(m[linha])):
      if m[linha][coluna] > maior:
        maior = m[linha][coluna]
        posicao = [linha,coluna]
  return posicao

A = [[1,2,3],
     [4,5,6],
     [7,8,9]]

B = [[1,0],
     [0,1]]

C = [[0,1],
     [1,0],
     [1,1]]

D = [[1,1,2],
     [2,2,1],
     [2,1,3]]


assert posicao_do_maior(A)==[2,2]
assert posicao_do_maior(B)==[0,0]
assert posicao_do_maior(C)==[0,1]
assert posicao_do_maior(D)==[2,2]